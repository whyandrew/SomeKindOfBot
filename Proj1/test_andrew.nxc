int color;
#define COLORSENSOR SENSOR_1


#define BLACK   1
#define WHITE   6
#define BLUE    2
#define GREEN   3
#define YELLOW  4
#define RED     5

#define MOTORS OUT_AC
#define LEFTMOTOR OUT_C 
#define RIGHTMOTOR OUT_A 

mutex motorMutex; // All motor movement changes use this mutex
#define FULLSPEED 40
#define SLOWSPEED 30

// amount to turn when going out of black route
//#define DEGREEADJUST 5
// amount in ms to backup when going out of black route
#define TIMEBACKUP 300

// From McGee
#define DEGREE360 1040
#define DEGREE180 520
#define DEGREE90  260
#define DEGREE45  130
#define DEGREE05  15

// Distance to be adjusted after sensor detects yellow intersection
// Use with FULLSPEED
#define CENTER_DISTANCE 125

/* Represents an interesection (yellow square) on the grid.

   Holds data on the surroundings of the intersection, namely coloured(or white)
   squares to the NE, SE, SW, NW of the interesection.
   
   Note that the directions are by default in terms of compass directions.
   When given a heading, the directions will change relative to the heading.
   */
struct intersection{

       int NE;
       int SE;
       int SW;
       int NW;
};

string colors[] = {
    "Color 0?",
    "Black   ",
    "Blue    ",
    "Green   ",
    "Yellow  ",
    "Red     ",
    "White   ",
    "Color 7?",
    "Color 8?",
    "Color 9?"
};

int lines[] = {
    LCD_LINE1,
    LCD_LINE2,
    LCD_LINE3,
    LCD_LINE4
};

/* function prototypes, to be added if needed
*/
intersection scan_surroundings();

/*
  Print color on LCD Screen Line 1
*/
inline void printColor(int color)
{
    TextOut(0, LCD_LINE1, colors[color]);
}

/*
    Take Color sensor reading 
    Return the most detected color
*/
int readColor(int numOfSamples)
{    
    int sample = 0;
    int colorSamples[] = {0,0,0,0,0,0,0}; // array index == color define
    int ret;

    for (int i = 0; i < numOfSamples; i++)
    {
        sample = COLORSENSOR;
        colorSamples[sample]++;        
    }

    ret = 1;
    for (int i = 2; i < 7; i++)
    {
        if (colorSamples[i] > colorSamples[ret])
        {
            ret = i;
        }
    }

    return ret;
}

inline void forwardFullSpeed() 
{
    OnFwdSync(MOTORS, FULLSPEED, 0);
}

inline void forwardSlowMo()
{
    OnFwdSync(MOTORS, SLOWSPEED, 0);
}

inline void reverse()
{
    OnRevSync(MOTORS, SLOWSPEED, 0);
}

inline void turnLeft45()
{
    RotateMotorEx(OUT_AC, FULLSPEED, DEGREE45, 100, true, true);
}

inline void turnRight45()
{
    RotateMotorEx(OUT_AC, FULLSPEED, DEGREE45, -100, true, true);
}

inline void turnLeft90()
{
    RotateMotorEx(OUT_AC, FULLSPEED, DEGREE90, 100, true, true);
}

inline void turnRight90()
{
    RotateMotorEx(OUT_AC, FULLSPEED, DEGREE90, -100, true, true);
}

inline void turn180()
{
    RotateMotorEx(OUT_AC, FULLSPEED, DEGREE180, -100, true, true);
}

inline void turn360()
{
    RotateMotorEx(OUT_AC, FULLSPEED, DEGREE360, -100, true, true);
}

inline void turn(bool left, int degrees)
{
    if (left)
    {
        RotateMotorEx(OUT_AC, FULLSPEED, degrees, -100, true, true);
    }
    else // turn right
    {
        RotateMotorEx(OUT_AC, FULLSPEED, degrees, 100, true, true);
    }
}

inline void reportError(string msg)
{
    TextOut(0, LCD_LINE1, "***********************");
    TextOut(0, LCD_LINE2, msg);
    TextOut(0, LCD_LINE3, "***********************");
    Wait(5000);
    Stop(true);
}

/*
    Handle moving back on black route, assume already out of bound
*/
void stayOnBlack()
{
    int factor = 1;
    // always try left side first, true == left
    bool whichSide = true; 
    bool isDone = false;

    TextOut(0, LCD_LINE2, "Moving back on road....");

    while (!isDone)
    {
        NumOut(0, LCD_LINE3, 5 * factor);

        turn(whichSide, DEGREE05 * factor);
        Wait(250);

        if (readColor(20) == BLACK)
        {
            isDone = true;
        }
        else
        {
            turn(!whichSide, DEGREE05 * factor * 2);
            Wait(250);
            if (readColor(20) == BLACK)
            {
                isDone = true;
            }
        }
        factor += 1;
        if (factor > 20)
        {
            reportError("ERROR: +100 degrees tested");
        }
    }

    ClearScreen();
}

/* Subroutine which moves the robot forward from one intersection to the next
*/
sub move_robot(){
    ////////////////////////////////////////////////////////////////////////////
    //  TO DO:
    //
    //  Complete this subroutine.
    //  Your robot will need to nagivates its way from one interesection to the
    //  next. If it reaches a red boundary, it will do a 180 degree turn and
    //  return to the previous intersection facing in the opposite direction.
    //
    //  You may need to account for motor "noise" as your robot will not always
    //  make turns perfectly and go straight forward each time.
    //
    ////////////////////////////////////////////////////////////////////////////

    int colorOutput;
    forwardFullSpeed();    

    while (true)
    {
        while ((colorOutput = readColor(50) == BLACK))
        {
            // spin until it's not black
        }

        Off(MOTORS);
        Wait(500);

        printColor(colorOutput);

        if (RED == colorOutput) // Hit red wall, do 180 turn
        {
            PlayToneEx((colorOutput + 1) * 100,400,1,FALSE);
            turn180();
            Wait(500);
            RotateMotorEx(MOTORS, SLOWSPEED, 50, 0, true, true);
            forwardFullSpeed();
        }
        else if (YELLOW == colorOutput) // yellow is intersection
        {
            PlayToneEx((colorOutput + 1) * 100,400,1,FALSE);
            Wait(1000);
            scan_surroundings();
            // After scanning intersection, need to move out of yellow first
            forwardFullSpeed();
            Wait(300); 
        }        
        else if (BLACK != colorOutput) // moving out of black road, get back.
        {
            //PlayToneEx((colorOutput + 1) * 100,400,1,FALSE);
            stayOnBlack();
            forwardFullSpeed();
        }
        else
        {
            forwardFullSpeed();
        }
    }
}

/* This function scans the surroundings of the robot.
   It takes readings of the colour of the 4 squares surrounding the
   intersection and returns an intersection variable which holds the data.
*/
intersection scan_surroundings(){
    intersection rsense;
    ////////////////////////////////////////////////////////////////////////////
    // TO DO:
    //
    // Implement a function in which the robot will scan the colour of the
    // surrounding squares at an interesection.
    // It will use the colour sensor to take readings from all four squares
    // in each of the NE, SE, SW, NW directions relative to the forward facing
    // direction of the robot.
    //
    ////////////////////////////////////////////////////////////////////////////

    ClearScreen();
    int curr_color;
    
    // Adjust sensor forward so wheels align with intersection, after this sensor should be over black
    if(readColor(10) == YELLOW) {
         RotateMotorEx(OUT_AC, SLOWSPEED, CENTER_DISTANCE, 0, true, true);
    }

    //RotateMotorEx(OUT_AC, SLOWSPEED, 20, 0, true, true);
    OnFwd(OUT_A, FULLSPEED);
    OnRev(OUT_C, FULLSPEED);
    int corners[4] = {0, 0, 0, 0};
    for (int i = 0; i<4; i++) 
    {
        until((curr_color = readColor(10)) != BLACK);
        corners[i] = curr_color;
        TextOut(0, lines[i], colors[corners[i]]);
        until(readColor(10) == BLACK);
    }

    Off(MOTORS);
    Wait(4000);

    ClearScreen();
    return rsense;
}




task main() {
    SetSensorColorFull(IN_1);

    move_robot();


    //forwardFullSpeed();
    
    // turnLeft90();
    // Wait(1000);
    // turnRight90();



    Wait(1000);


}

