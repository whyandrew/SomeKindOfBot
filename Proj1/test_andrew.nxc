int color;
#define COLORSENSOR SENSOR_1


#define BLACK   1
#define WHITE   6
#define BLUE    2
#define GREEN   3
#define YELLOW  4
#define RED     5

#define MOTORS OUT_AC
#define LEFTMOTOR OUT_C 
#define RIGHTMOTOR OUT_A 

mutex motorMutex; // All motor movement changes use this mutex
#define FULLSPEED 30
#define SLOWSPEED 20

// Amount of wheel degree rotation to get 45/90/180 degree turn
#define DEGREE45    150

// amount to turn when going out of black route
//#define DEGREEADJUST 5
// amount in ms to backup when going out of black route
#define TIMEBACKUP 500

// From McGee
#define TURNSPEED 40
#define DEGREE360 1040
#define DEGREE180 520
#define DEGREE90  260

/* Represents an interesection (yellow square) on the grid.

   Holds data on the surroundings of the intersection, namely coloured(or white)
   squares to the NE, SE, SW, NW of the interesection.
   
   Note that the directions are by default in terms of compass directions.
   When given a heading, the directions will change relative to the heading.
   */
struct intersection{

       int NE;
       int SE;
       int SW;
       int NW;
};

/* function prototypes, to be added if needed
*/
intersection scan_surroundings();

/*
  Print color on LCD Screen Line 1
*/
inline void printColor(int color)
{
    if (BLACK == color)
        TextOut(0, LCD_LINE1, "BLACK   ");
    else if (WHITE == color)
        TextOut(0, LCD_LINE1, "White   ");
    else if (BLUE == color)
        TextOut(0, LCD_LINE1, "BLUE    ");
    else if (RED == color)
        TextOut(0, LCD_LINE1, "RED     ");
    else if (GREEN == color)
        TextOut(0, LCD_LINE1, "GREEN   ");
    else if (YELLOW == color)
        TextOut(0, LCD_LINE1, "YELLOW  ");
}

/* 
    Take a few more readings
    Return true if all readings are the same as input colorDefine, else false
*/
bool confirmColor(int colorDefine)
{
    // TODO: need to use some stats model? Or 9/10 is ok?

    int readCounts = 50;
    bool ret = true;

    for (; readCounts > 0; readCounts--)
    {
        if (colorDefine != COLORSENSOR)
        {
            ret = false;
        }
    }

    return ret;
}

/*
    Take Color sensor reading 
    Return int-average of 10 readings
*/
int readColor()
{
    int counts = 10;
    int sum = 0;
    for (int i = 0; i < counts; i++)
    {
        sum += COLORSENSOR;
    }

    return ((sum / counts));
}

inline void forwardFullSpeed() 
{
    OnFwdSync(MOTORS, FULLSPEED, 0);
}

inline void forwardSlowMo()
{
    OnFwdSync(MOTORS, SLOWSPEED, 0);
}

inline void reverse()
{
    OnRevSync(MOTORS, SLOWSPEED, 0);
}

inline void turnLeft45()
{
    RotateMotorEx(OUT_AC, SLOWSPEED, DEGREE45, 100, true, true);
}

inline void turnRight45()
{
    RotateMotorEx(OUT_AC, SLOWSPEED, DEGREE45, -100, true, true);
}

inline void turnLeft90()
{
    RotateMotorEx(OUT_AC, SLOWSPEED, DEGREE90, 100, true, true);
}

inline void turnRight90()
{
    RotateMotorEx(OUT_AC, SLOWSPEED, DEGREE90, -100, true, true);
}

inline void turn180()
{
    RotateMotorEx(OUT_AC, TURNSPEED, DEGREE180, -100, true, true);
}

inline void turn360()
{
    RotateMotorEx(OUT_AC, TURNSPEED, DEGREE360, -100, true, true);
}

inline void turn(bool left, int degrees)
{
    if (left)
    {
        RotateMotorEx(OUT_AC, SLOWSPEED, degrees, -100, true, true);
    }
    else // turn right
    {
        RotateMotorEx(OUT_AC, SLOWSPEED, degrees, 100, true, true);
    }
}

/*
    Handle moving back on black route, assume already out of bound
*/
void backOnBlack()
{
    /*
        First backup abit, then adjust heading using argument, then move forward
    */
    //bool left = true;
    int adjustment = 0;
    int increment = 15;
    // always try left side first
    bool tryLeft = true;
    
    // Use for testing forward move, assume using forwardSlowMo()
    int count = 10;
    int timeSlice = 50;
    
    TextOut(0, LCD_LINE2, "BackOnBlack....");

    while (BLACK != readColor())
    {
        count = 20;
        // only increment once each left and right sides are tested
        if (tryLeft)
        {
            adjustment += increment;
        }
        
        NumOut(0, LCD_LINE3, (adjustment) );
        if (tryLeft)
        {
            TextOut(0, LCD_LINE4, "LEFT   ");
        }
        else
            TextOut(0, LCD_LINE4, "RIGHT   ");
            
        reverse();
        until (BLACK == readColor());
        printColor(readColor());
        Wait(TIMEBACKUP);    // this is a guess work... and hope it doesn't hit a tight angle which it will hit black and quickly hit non-black again
        printColor(readColor());
        Off(MOTORS);
        if (tryLeft)
        {
            turn(true, adjustment);
        }
        else // since left side didn't work, need to turn 2*adjust to right side
        {
            turn(false, 2 * adjustment);
        }
        
        printColor(readColor());
        Off(MOTORS);

        forwardSlowMo();
        //Wait(TIMEBACKUP);
        bool isBlack = true;
        for (; (count > 0) && isBlack; count--)
        {
            Wait(timeSlice);
            int reading = readColor();
            isBlack = (BLACK == reading);
            printColor(reading);
        }
            
        //until (BLACK != readColor());
        Off(MOTORS);
        printColor(readColor());
        Wait(1500);
        tryLeft = !tryLeft;
    }
    
    TextOut(0, LCD_LINE2, "EXIT                ");
    Wait(1000);
}


/* Subroutine which moves the robot forward from one intersection to the next
*/
sub move_robot(){
    ////////////////////////////////////////////////////////////////////////////
    //  TO DO:
    //
    //  Complete this subroutine.
    //  Your robot will need to nagivates its way from one interesection to the
    //  next. If it reaches a red boundary, it will do a 180 degree turn and
    //  return to the previous intersection facing in the opposite direction.
    //
    //  You may need to account for motor "noise" as your robot will not always
    //  make turns perfectly and go straight forward each time.
    //
    ////////////////////////////////////////////////////////////////////////////

    int colorOutput;
    forwardFullSpeed();    

    while (true)
    {
        colorOutput = readColor();
        //NumOut(0, LCD_LINE2, colorOutput);
        printColor(colorOutput);


        if (RED == colorOutput) // Hit red wall, do 180 turn
        {
            Off(MOTORS);
            if (confirmColor(RED))
            {
                PlayToneEx((colorOutput + 1) * 100,400,1,FALSE);
                turn180();
                Wait(500);
                RotateMotorEx(MOTORS, SLOWSPEED, 50, 0, true, true);
                Wait(500);
                forwardFullSpeed();
            }
            else 
            {
                forwardFullSpeed();
            }
        }
        
        else if (YELLOW == colorOutput) // yellow is intersection
        {
            Off(MOTORS);  
            if (confirmColor(YELLOW))
            {
                PlayToneEx((colorOutput + 1) * 100,400,1,FALSE);
                scan_surroundings();
                // After scanning intersection, need to move out of yellow first
                forwardFullSpeed();
                Wait(300); 
            }
            else
            {
                forwardFullSpeed();
            }
        }        
        else if (BLACK != colorOutput) // moving out of black road, get back.
        {
            Off(MOTORS);  
            if (confirmColor(colorOutput))
            {
                PlayToneEx((colorOutput + 1) * 100,400,1,FALSE);
                backOnBlack();
                forwardFullSpeed();

                Wait(300); // remove later
            }
            else
            {
                forwardFullSpeed();
            }

        }
        Wait(10);
    }
}

/* This function scans the surroundings of the robot.
   It takes readings of the colour of the 4 squares surrounding the
   intersection and returns an intersection variable which holds the data.
*/
intersection scan_surroundings(){
    intersection rsense;
    ////////////////////////////////////////////////////////////////////////////
    // TO DO:
    //
    // Implement a function in which the robot will scan the colour of the
    // surrounding squares at an interesection.
    // It will use the colour sensor to take readings from all four squares
    // in each of the NE, SE, SW, NW directions relative to the forward facing
    // direction of the robot.
    //
    ////////////////////////////////////////////////////////////////////////////


    // TODO
    

    return rsense;
}




task main() {
    SetSensorColorFull(IN_1);

    move_robot();


    //forwardFullSpeed();
    
    // turnLeft90();
    // Wait(1000);
    // turnRight90();



    Wait(1000);


}

